---
title: "グレースフルシャットダウンの必要性"
emoji: "💬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics:
  - "Go"
  - "グレースフルシャットダウン"
  - "gin"
  - "AWS"
  - "SIGTERM"
published: false
---

こんにちは、[@nerusan_main](https://twitter.com/nerusan_main)です。

皆さんは、グレースフルシャットダウンという言葉を聞いたことはありますでしょうか？
今回は、グレースフルシャットダウンについて、以下のことお話しできればと思います。

* グレースフルシャットダウンとはなんのか？
* グレースフルシャットダウンはなぜ必要なのか？
* Go言語においてグレースフルシャットダウンをどうやって実装するのか？

では、話していきます！

## グレースフルシャットダウンとは

グレースフルシャットダウンとは、一言でいうとプログラムやシステムを正常に終了させるための手法です。
通常、プログラムやシステムは予期せぬエラーや問題によって異常終了することがありますが、グレースフルシャットダウンを実装することで、異常終了を最小限に抑えることができます。

## グレースフルシャットダウンの必要性

グレースフルシャットダウンを実装することには以下のような利点があります：

1. データの損失を最小限に抑えることができる。
2. ユーザーエクスペリエンスを向上させることができる。
3. システムの安定性を高めることができる。

もし、処理中にサーバーが異常終了すると、データが保存されずデータの整合成が取れなくなったり、処理が途中で中断する可能性があります。
処理の整合が求められるサービスにとって、これはよくありません。

グレースフルシャットダウンでは、進行中の処理を終了してからシャットダウンするため、データが保存されないということは起きません。

## サーバーっていつ異常終了するの？

ここまで見てみて、グレースフルシャットダウンの有効性はわかりました。
しかし、本番のサーバーってそんな突然終了することがあるの？って思いませんか？
自分自身もそうでした😅

昨今、サーバーレスにサービスを構築することが多いと思いますが、
このサーバーレスのサーバーでは起きる可能性があります。

例えば、AWSのECSとFargateで構成されたサービスを考えます。

ECSは、AWS内部におけるハードウェア障害やセキュリティ脆弱性が存在するプラットフォームであると判断された場合、
新しいECSタスクに置き換える「リタイア」と呼ばれるイベントが発生します。

リタイアが発生すること、ECSからサーバー(Fargate)にリタイア通知(SIGTERMシグナル)を送信したします。
その後に起動中のサーバーを中断し、プラットフォームの更新、サーバー再度起動が行われるわけです。

https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-maintenance.html

:::message
サーバーを自分で管理する場合は、プラットフォーム更新は自身で行わない限り、サーバーを止めるを止める必要がないため、
サーバーレスの場合と書きましたが自身で更新する場合は、同様に起動中のサーバーを止める必要があるため、グレースフルシャットダウンを実装するべきです。
プラットフォーム更新の場合だけでなく意図せず終了する可能性は0ではないため、どちらにしよグレースフルシャットダウンの処理を入れるべきですが、、、
:::jjj

このSIGTERMシグナルがポイントであり、この通知を送信後、
デフォルトで30秒後に強制終了するSIGKILLシグナルを送り、サーバーを強制終了させます。
この強制終了でデータの不整合が起こる可能性があります。

グレースフルシャットダウンでは、SIGTERMシグナルを受けった後に、正常にシャットダウンすることで、データの不正が起きないようすることになります。

例えると、パソコンの電源をいきなり抜くのが強制終了で、
30秒後に強制終了するよ！と通知を受けてから処理を最後まで終わらせた後に正規の手順でシステムを終了するのが、グレースフルシャットダウンになります。

## グレースフルシャットダウンお処理の流れ

処理の流れは以下になります。

1. SIGTERMシグナル受け取る
2. 今やっている処理を最後まで終わらせる
3. シャットダウンを行う

## グレースフルシャットダウンの実装方法

グレースフルシャットダウンを実現するためのコードを以下に記載します。
環境は以下です。
- フレームワーク: [Gin](https://gin-gonic.com/)
- Goバージョン: 1.22


```go:server.go
// サーバー起動
//
// @params
// ctx コンテキスト
func (s *Server) Run(ctx context.Context) error {
	ctx, stop := signal.NotifyContext(ctx, os.Interrupt, syscall.SIGTERM)
	defer stop()
	eg, ctx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		// http.ErrServerClosed は
		// http.Server.Shutdown() が正常に終了したことを示すので異常ではない
		if err := s.srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Printf("failed to close: %+v", err)
			return err
		}
		return nil
	})

	// SIGTERMシグナルなどの終了通知を待つ
	<-ctx.Done()
	// サーバーをシャットダウン
	log.Println("shutdown server ...")
	if err := s.srv.Shutdown(context.Background()); err != nil {
		log.Printf("failed to shutdown: %+v", err)
	}
	// 別ルーチンのグレースフルシャットダウンの終了を待つ
	return eg.Wait()
}
```

全てのコードは以下に実装しているので参考にしてみてください。

https://github.com/hack-31/point-app-backend

`server.go`についてみてみます。

関数の中で、signal.NotifyContext関数を使用して新たなコンテキストを作成しています。
この関数は、指定した終了シグナル（ここではos.Interruptとsyscall.SIGTERM）が受信されたときにコンテキストをキャンセルします。
これにより、Ctrl+Cが押されたときやSIGTERMシグナルが送信されたときにサーバーを停止することができます。

次に、errgroup.WithContext関数を使用して新たなエラーグループとコンテキストを作成しています。
エラーグループは、複数のゴルーチンを管理し、そのいずれかでエラーが発生した場合にそれを報告します。

エラーグループのGoメソッドを使用して新たなゴルーチンを作成し、その中でhttp.ServerのListenAndServeメソッドを呼び出してサーバーを起動しています。
このメソッドは、エラーが発生した場合にそれを返しますが、サーバーが正常にシャットダウンした場合にはhttp.ErrServerClosedを返します。
そのため、エラーチェックではこの値を無視しています。

最後に、コンテキストのDoneメソッドを使用して終了シグナルを待ち、サーバーのシャットダウンを開始します。
シャットダウンは、アクティブな接続を中断せずにサーバーを正常にシャットダウンします。
シャットダウンは、まず開いているすべてのリスナーを閉じ、次にアイドル状態の接続をすべて閉じ、接続がアイドル状態に戻るまで無期限に待機してからシャットダウンします。

そして、エラーグループのWaitメソッドを使用して、サーバーを起動しているゴルーチンが終了するのを待ちます。
これにより、サーバーはすべてのリクエストを処理し終えてからシャットダウンする、いわゆる「グレースフルシャットダウン」を実現しています。

流れをまとめると以下になります。

1. ListenAndServeメソッドでサーバーを起動し、`<-ctx.Done()`でキャンセル通知が来るまで待機
2. SIGTERMシグナルで受信した後にShutdownメソッドでシャットダウン処理を実行
3. 正常にシャットダウンが成功したらListenAndServeメソッドは`http.ErrServerClosed`を返す
4. `eg.Wait()`のエラーに`nil`が返却

## まとめ

以上がグレースフルシャットダウンの必要性についての説明です。
グレースフルシャットダウンを実装することで、プログラムやシステムの安定性を向上させることができます。
クラウドのサーバーレスを利用している場合は、必ず実装をするようにしましょう。
