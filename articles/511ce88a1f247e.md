---
title: "MySQLのカバリングインデックス完全ガイド：仕組みから設計まで"
emoji: "⚡"
type: "tech"
topics: ["mysql", "database", "sql", "performance", "innodb"]
published: true
---

# はじめに
MySQLのパフォーマンスチューニングにおいて、インデックスは不可欠な要素です。その中でも「カバリングインデックス」は、特定のクエリを劇的に高速化できる非常に強力な手法です。

この記事では、MySQL (InnoDB) のインデックスの基本的な仕組みから、カバリングインデックスがどのように機能し、どう設計すれば良いのかを具体例と共に詳しく解説します。

## MySQL (InnoDB) のインデックスの基本
カバリングインデックスを理解するには、まずInnoDBストレージエンジンにおける「プライマリインデックス」と「セカンダリインデックス」の根本的な違いを知る必要があります。

### 1. プライマリインデックス (クラスタ化インデックス)
プライマリインデックスは、テーブルの主キー（`PRIMARY KEY`）に対して自動的に作成される特別なインデックスです。

- **実データと一体化**: InnoDBでは、テーブルのデータそのものがプライマリインデックスの順序に従って物理的にディスクに格納されます。つまり、**プライマリインデックスのリーフノード（末端）には、行の全データが格納されています**。
- **常に1つだけ**: その構造上、1つのテーブルに1つしか存在できません。
- **常にカバリングインデックス**: プライマリインデックスを検索すれば、そこに行の全データがあるため、追加のデータアクセスは一切不要です。そのため、プライマリインデックスは常にカバリングインデックスとして機能します。

### 2. セカンダリインデックス (非クラスタ化インデックス)
主キー以外に、`CREATE INDEX`などで任意に作成するインデックスがセカンダリインデックスです。

- **プライマリキーへのポインタを持つ**: セカンダリインデックスのリーフノードには、インデックスが設定されたカラムの値と、**その行に対応する「プライマリキーの値」**が格納されています。
- **ルックアップの発生**: セカンダリインデックスを使って検索を行う場合、まずインデックスを辿って目的のプライマリキーを見つけます。しかし、クエリがインデックスに含まれていない他のカラム（例: `age`や`email`）を要求している場合、次に見つけたプライマリキーを使って**プライマリインデックスを再度検索し、行の完全なデータを取得しにいきます**。この追加の検索処理を「**ブックマークルックアップ**」または単に「**ルックアップ**」と呼びます。

この「ルックアップ」こそが、セカンダリインデックスを使った検索でパフォーマンスのボトルネックになり得る処理です。

## カバリングインデックスとは？
カバリングインデックスとは、**クエリが必要とする全てのカラムを内包することで、セカンダリインデックス検索時に発生する「ルックアップ」を不要にするインデックス**のことです。

クエリが必要とする情報がすべてセカンダリインデックス内に収まっているため、MySQLはテーブル本体（プライマリインデックス）にアクセスすることなく、**セカンダリインデックスを読むだけで処理を完結**させることができます。これを「インデックスオンリースキャン」と呼び、`EXPLAIN`の結果では`Extra`列に `Using index` と表示されます。

## 具体例で理解する
`users`テーブルを例に、カバリングインデックスの効果を見ていきましょう。

```sql
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100),
  email VARCHAR(100),
  age INT
);

-- nameとemailに複合セカンダリインデックスを作成
CREATE INDEX idx_name_email ON users (name, email);
```

### ケース1: カバリングインデックスが有効になるクエリ

```sql
-- nameで検索し、nameとemailを取得する
SELECT name, email FROM users WHERE name = 'Taro Yamada';
```

このクエリの実行計画は以下の通りです。
1. `WHERE`句で使う`name`、`SELECT`句で要求する`name`と`email`は、すべて`idx_name_email`インデックスに含まれています。
2. MySQLは`idx_name_email`をスキャンするだけで必要な情報をすべて得られるため、プライマリインデックスへの**ルックアップは発生しません**。
3. これがカバリングインデックスとして機能している状態であり、非常に高速です。

![](https://storage.googleapis.com/zenn-user-upload/28c70253f77d-20250713.png)

### ケース2: カバリングインデックスにならないクエリ

```sql
-- nameで検索し、nameとageを取得する
SELECT name, age FROM users WHERE name = 'Taro Yamada';
```

このクエリではどうでしょうか。
1. `WHERE`句で使う`name`は`idx_name_email`インデックスに含まれているため、高速に目的の行のプライマリキーを見つけることができます。
2. しかし、`SELECT`句が要求する`age`カラムはインデックスに含まれていません。
3. そのため、MySQLはステップ1で見つけたプライマリキーを使い、**プライマリインデックスへのルックアップを行い**、`age`の値を取得します。
4. この場合、`idx_name_email`はカバリングインデックスとしては機能しません。

![](https://storage.googleapis.com/zenn-user-upload/3280544fb012-20250713.png)

## メリットと注意点

### メリット
- **I/O操作の劇的な削減**: ルックアップのためのディスクI/Oがなくなるため、クエリが非常に高速になります。
- **キャッシュ効率の向上**: インデックスはテーブルデータ全体よりもサイズが小さいため、メモリにキャッシュされやすく、さらなる高速化が期待できます。

### 注意点
- **インデックスサイズの増加**: 多くのカラムをインデックスに含めると、その分ディスク容量を消費します。
- **書き込み性能の低下**: `INSERT`や`UPDATE`時、インデックスも更新する必要があるため、インデックスが大きくなるほど書き込みのオーバーヘッドが増加します。
- **保守性の低下**: クエリの`SELECT`句が変わると、カバリングインデックスが効かなくなる可能性があります。クエリの変更に合わせてインデックスの設計を見直す必要があります。

## まとめ
- **プライマリインデックス**は行の全データを持つため、常にカバリングインデックスです。
- **セカンダリインデックス**は、クエリが必要とする全カラムを含む場合に**カバリングインデックスとして機能**し、プライマリインデックスへの**ルックアップを省略**することで、パフォーマンスを大幅に向上させます。

カバリングインデックスは、特に読み取り処理が多いシステムにおいて絶大な効果を発揮する最適化手法です。メリットとデメリットをよく理解し、アプリケーションのクエリ特性に合わせて戦略的に設計することが重要です。

## 参考

https://zenn.dev/akito_ima/articles/dd8f02c46619e9

https://techinfoofmicrosofttech.osscons.jp/index.php?SQL%20Server%20%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9https://strong-engineer.com/db/database-indexing-strategy-guide-for-beginners/

https://docs.teradata.com/r/0rYfghiYcBZf2Y_ffU5UtA/SQFEE92zsO90W7R2I14Omg

https://aws.amazon.com/jp/builders-flash/202407/dynamodb-secondary-index/

https://learn.microsoft.com/ja-jp/sql/relational-databases/indexes/create-clustered-indexes?view=sql-server-ver16

https://yakst.com/ja/posts/346
