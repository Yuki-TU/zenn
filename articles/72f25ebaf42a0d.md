---
title: "みんな使ってる？React Queryで快適なAPI通信を実現しよう！"
emoji: "🙌"
type: "tech"
topics:
  - "nextjs"
  - "react"
  - "typescript"
  - "reactquery"
published: true
published_at: "2022-05-23 02:55"
---

こんにちは、@nerusan_mainです。

フロントエンド開発において、API経由でデータを取得や送信するサービスは多いです。その時、axiosやfetch関数を利用してtry/catchでデータを取得するかなって思います。例えば以下のようなソースコードです。

```ts:sample.tsx
// データを取得する
const [data, setData] = useState({name: ''})

// このページに法問した時に一度だけ実行
React.useEffect(() => {
  try {
    (async () => {
      //　データを取得
      const data = await axiod.get('https://endopoint.url');
      // 正常系レスポンスの処理
      // 取得データ尾をステートで管理
      setData(data);
    })();
  } catch (err) {
     // 取得に失敗すれば、例外をスローし、エラー内容に応じてユーザに通知する
}, [])

  return (
    <div>
      <p>{data.name}</p>
    </div>
  );
  
```

また、取得する間は、ローディングをユーザに表示させることが望ましいですが、実装はなかなかめんどくさかったり、忘れたります。

また、ページを開くたびにリクエストを行うと、通信環境が悪い環境では、すぐデータが表示されず、ユーザにストレスを与えるサービスになりかねません。

そこで、便利なツールとして[react-query](https://react-query.tanstack.com/)を紹介します。同じようなツールとして、[swr](https://swr.vercel.app/ja)がありますが、useQueryの方が機能が豊富であり、使いやすい印象があります。ですので、こんかいは、react-queryを紹介します。


# どんなことができるの？

以下のようなことができます。

* 宣言的に処理を記述でき、簡潔になり、ローディングとエラー表示が簡単
* キャッシュを利用して素早やくユーザに情報を表示できる
* Devツールが便利

以下、詳しく見ていきます。

# 宣言的に処理を記述でき、簡潔になり、ローディングとエラー表示が簡単

実際に取得の利用するuseQueryを利用した例を見てみます。

```tsx:sample.tsx
  const { isLoading, error, data, isFetching } = useQuery("repoData", () =>
    axios.get(
      "https://api.com"
    ).then((res) => res.data)
  );
  // ローディング中はローディングを表示
  if (isLoading) return <Loding />;

  // エラーならエラー表示
  if (error) return <Error message={error.message} />

  return (
    <div>
      <p>{data.name}</p>
    </div>
  );
```

どうでしょうか？ずいぶんスッキリし、わかりやすいコードになったのではないでしょうか？

useQueryでは、ローディングフラグ、エラー、取得データを返却してくるので、それに沿って、ユーザに表示したい、コンポーネントを返してあげるだけで済みます。

このように記述できるのは、ローディング、エラー表示実装忘れを防ぐことができそうです。

# キャッシュを利用して素早やくユーザに情報を表示できる

useQueryを利用することで、サーバからデータを取得するとデフォルトで5分間キャッシュに保存されます。([参照](https://react-query.tanstack.com/guides/testing#set-cachetime-to-infinity-with-jest))。キャッシュ保存中であれば一度アンマウントしたコンポーネントを再度マウントするとキャッシュからデータを取得するので、すぐブラウザにデータを描写することができます。

つまり、一度訪れたページに、再度戻ってくる場合に、キャッシュデータを素早く表示してくれるので、ユーザはストレスなくブラウジングができます。

また、デフォルトでは、キャッシュを先に表示したあとすぐに、バックグランドでサーバーからデータをフェッチして、データの更新があればユーザに表示します。(この値はオプションのstaleTimeで変更可能。デフォルトでは`0`なので、表示したあとすぐにフェッチする)

なので、古いデータじゃないかという心配もいりませんね！

詳しいオプションについて[こちら](https://react-query.tanstack.com/reference/useQuery#_top)をご覧ください。

# dev toolが便利

react-queryには、便利なdevツールが用意されており、こちらが便利です。
具体的には、それぞれのリクエストなどのキャッシュ情報やステートの詳細を知ることができます。

ここのクエリは設定はどのようになっているんだろうっといった場合に、ここを見ると良いかもしれません。


# POST、DELETEにも対応
また、取得のGETだけではなくPOSTやDELETEなどにも対応しています。その時は、`useMutation`を利用します。例えば、送信ボタンを押して、データを送信する場合などにも使えます。

ソースコード0は以下のようにします。

```tsx:sample.tsx
   const mutation = useMutation((postData: {name: string}) => {
     return axios.post('http://api.com/', postData)
   })
 
   return (
     <div>
       {mutation.isLoading ? (
         'データ追加中'
       ) : (
         <>
           {mutation.isError ? (
             <div>エラーがおきました: {mutation.error.message}</div>
           ) : null}
 
           {mutation.isSuccess ? <div>追加が成功しました</div> : null}
 
           <button
             onClick={() => {
               mutation.mutate({ name: "田中" })
             }}
           >
             追加する
           </button>
         </>
       )}
     </div>
   )
 }
```

POSTでも簡単にエラー表示、ローディング、成功時の処理が行えるのはとても便利ですね！
詳しい例題は[こちら](https://react-query.tanstack.com/guides/mutations)。

# まとめ

以上、react-queryについての簡単に説明しました。特に、クライアントサイドレンダリングを行うReactの場合は、キャッシュを利用することでユーザに素早い表示を行えることができるので、UXが上がりそうです。

コードもスッキリし、可読性も上がり、ローディング処理、エラー処理も忘れずに行えそうなので、是非積極的に使っていきたいツールですね:)

# 参考
https://reffect.co.jp/react/react-use-query#i-2
